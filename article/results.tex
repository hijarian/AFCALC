\chapter{Анализ полученных результатов}\label{chapter:results}

\section{Результаты вычислений и их интерпретация}\label{section:results-plots}
Для разработанной программы был сформирован ряд тестов, для массового вывода графиков с вариацией того или иного параметра модели.
Было получено более 150 различных графиков, после чего дальнейшие эксперименты были признаны несущественными для оценки работы.

В таблице \ref{tbl:plots} приведены сведения о параметрах, использованных в некоторых проверочных запусках. Параметры точности оставались неизменными: интегрирование производилось по сетке частотой в 50 отрезков, тета-функции представлялись рядами из 25 элементов, и количество вычисляемых $c_n$  было равно 30.

\begin{table}[!th]
  \begin{center}
    \begin{tabular}{| l | l | l | l | l | l | l | l |}
      \hline
      График на рис.& $\varphi_0$ & $v_0$ & $\tau$ & $\alpha$ & $a$ & $b$ \\
      \hline
      \ref{fig:plot1} & 100 & 0.2 & 0.7 & 0.7 & 1 & 5 \\
      \hline
      \ref{fig:plot2} & 100 & 0.2 & 0.6 & 0.7 & 1 & 5 \\
      \hline
      \ref{fig:plot3} & 100 & 0.2 & 0.7 & 0.49 & 1 & 5\\
      \hline
    \end{tabular}
  \end{center}
  \caption{Параметры трёх различных тестов черчения границы воронки взрыва. Точность вычислений не менялась}
  \label{tbl:plots}
\end{table}

Было замечено, что параметры $\varphi_0$ и $v_0$ влияют только на масштаб чертежа.
При увеличении $\varphi_0$ чертёж увеличивается (граница отдаляется от начала координат), а при увеличении $v_0$ --- уменьшается (граница приближается к началу координат).
Эти результаты естественным образом следуют из построения функции \eqref{eq:dz/du}, где эти параметры выступают в качестве коэффициентов.

Параметры $a$ и $b$, представляющие собой длины радиусов эллипса, который является формой заряда, оказывают также масштабирующее влияние на чертёж.
При этом при задании какого-либо $b$ так, что $b < a$ программа начинает выдавать векторы из ошибочных значений <<NaN>> при вычислении коэффициентов $c_n$ для выражения $f(u)$.

Параметры $|\tau|$ и $\gamma$ оказывают намного более существенное влияние на чертёж.
Оба этих параметра искажают и поворачивают границу, изображённую на графике, причём весьма сложным образом.
Для определения особенностей влияния $\gamma$ и $|\tau|$ на расположение и форму изображения границы воронки взрыва следует провести дополнительное исследование.

В целом интерпретация полученных результатов затруднена.
На фоне аналитически верных математических формул, лежащих в основе производимых вычислений, не поддающиеся расшифровке производимые программой графики представляют собой проблему для дальнейшего применения результатов данной работы.

Следует отметить, что из-за особенностей численной реализации вычисления значений тета-функций, в случае задания более чем 25 слагаемых в ряду, представляющем тета-функции (иными словами, в случае, когда $n_{theta} > 25$), тета-функции начинают расходиться и их вычисление крайне замедляется. Это происходит из-за накопления ошибки. Уже при $n_{theta} > 10$ параметр $q$, входящий в разложение тета-функций, начинает возводиться в степень $n^2$, где $n > 10$, а при условии, что $|q| < 1$, получается, что все слагаемые в разложении тета-функции, после десятого становятся исчезающе малы.

\begin{figure}[]
  \begin{center}
    \includegraphics[width=12cm]{plot1}
    \caption{Чертёж границы воронки взрыва при первом тестовом наборе параметров}
    \label{fig:plot1}
  \end{center}
\end{figure}
\begin{figure}[]
  \begin{center}
    \includegraphics[width=12cm]{plot2}
    \caption{Чертёж границы воронки взрыва при втором тестовом наборе параметров}
    \label{fig:plot2}
  \end{center}
\end{figure}
\begin{figure}[]
  \begin{center}
    \includegraphics[width=12cm]{plot3}
    \caption{Чертёж границы воронки взрыва при третьем тестовом наборе параметров}
    \label{fig:plot3}
  \end{center}
\end{figure}

\section{Оценка производительности}\label{section:results-calcs}
Вычисления производились на AMD Athlon 64 X2 Dual Core 5000+ 1.96 GB оперативной памяти. 
Сразу же следует заметить, что в случае компиляции программы производительность возрастает на 200\%.
В среднем время выполнения программы составляет 40 секунд плюс-минус пять при любом наборе входных параметров.

Ошибка, связанная с количеством элементов, представляющих тета-функции, проявляется и на производительности. В случае превышения количества элементов дальше 25 производительность программы падает.

На одну итерацию вычисления $c_n$ на тестовом компьютере требуется от 5.9 до 6.9 секунд.
На вычисление координат 50 точек, например, для постройки рисунка одной из границ области $z(u)$, требуется 7 секунд.
Эти сведения по времени выполнения актуальны для скомпилированного приложения, выполняемого в среде GNU \textbackslash Linux.

Внедрение техник полуавтоматического распараллеливания, предоставляемых компилятором GHC, дало противоречивые результаты.
При внедрении какого-либо кода, предназначенного для указания на параллельные вычисления, в программу, производительность конечного приложения падает на 20\%.
Данное наблюдение распространяется на любые вычисления, проводимые программой.

При наличии в программе кода для осуществления параллельных вычислений и использовании аргументов командной строки \verb!+RTS -N2! во время запуска программы время выполнения увеличивается.
При семантически однопоточном коде и использовании одного только указания \verb!+RTS -N2! производительность тоже падает, хотя и менее значительно.

Такое поведение приложения связано, очевидно, с тем, что в операционной системе, в которой выполняется приложение, работает свой собственный механизм распараллеливания задач. Это предположение подтверждается наблюдением за нагрузкой процессора сторонними приложениями.

Применение методики увеличения объёма кучи и стека, выделяемых на программу, с целью уменьшения количества вызовов сборщика мусора, также понижает производительность. Следует, однако, отметить при этом, что количество запусков сборщика мусора действительно уменьшается.
Был произведён эксперимент с запуском приложения, выделив ему 100 MB для стека и 500 MB для кучи. Время, проведённое за сборкой мусора, уменьшилось с 2 сек, получаемых при запуске с параметрами по умолчанию, до 0.2 сек.
При этом суммарное время выполнения программы увеличилось.

Определённо, можно сделать вывод о том, что, кроме, собственно, применения техник распараллеливания, а тем более, таких специфичных, как предоставляемых средой выполнения Haskell, требуется ещё дополнительно проводить исследования для выявления участков кода, распараллеливание которых действительно приведёт к повышению производительности.
В остальных случаях компиляция с оптимизацией, предоставляемая GHC, позволяет добиться наилучшей производительности без применения каких-либо дополнительных техник. 
