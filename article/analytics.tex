\chapter{Аналитический обзор}

\section{Обзор исследований по математическому моделированию взрывов}
Исследованию механизма взрыва в грунтах в середине XX века посвящено много работ.
Интерес к этой теме был вызван как практическими, так и теоретическими соображениями.
Сложность явления, большой диапазон изменений параметров (напряжений, скоростей и др.), разнообразие условий и назначения взрыва представляют благоприятную и увлекательную тему для исследователя, для его изобретательности и интуиции.
Большое значение при этом имеет и практическое использование взрывов в грунтах и горных породах. Взрывы применяются при разработке полезных ископаемых, при проходке траншей, при сооружении плотин. Например, большая плотина в Медео (близ Алма-Аты) и гидротехнический комплекс в Нуреке (Таджикистан) были сооружены с использованием энергии взрыва.

После работ О.~Е.~Власова, применившего импульс\-но-гидро\-дина\-ми\-ческую постановку (ИГП) к изучению взрыва, и пионерских работ \\ М.~А.~Лаврентьева и В.~М.~Кузнецова, поставивших и решивших ряд краевых задач теории взрыва, появилось большое количество статей, посвящённых исследованию задач взрыва в ИГП (к 1990 г. их библиография насчитывала свыше 150 наименований; большая их часть была выполнена в Новосибирске, Киеве, Казани и Москве).
Из монографий, в которых рассматриваются задачи взрыва в ИГП, ближе всего к теме настоящей работы книга В. М. Кузнецова \cite{diploma:Kuznetsov2} и книга Ильинского \cite{phys:Ilyinskij}. 

Использующаяся в данной работе твёрдо-жидкостная модель сильно схематизирует явление, на зато она приводит его к сравнительно простому математическому описанию.
Основное упрощение в импульсной модели состоит в том, что среда предполагается несжимаемой, в результате чего исчезает из поля зрения волновой процесс и математически задача сводится к краевой задаче для эллиптических уравнений (в случае несжимаемой среды --- к задаче для уравнения Лапласа).
При помощи такой модели, конечно, нельзя ответить на все вопросы; однако на некоторые (не только качественные, но и количественные) ответ получается с достаточной степенью приближения.

В данной работе решается самая очевидная задача, которая может быть решена при помощи ТЖМ --- задача определения границы воронки выброса.
В импульсной модели остался недостаточно обоснованным выбор критерия, определяющего эту границу.
Причина возникающей при этом трудности понятна --- здесь ставится вопрос о критерии прочности, критерии разрушения, т. е. возникает новый физический вопрос, который не может быть решён простым моделированием среды несжимаемой жидкостью.
Обычным решением данной проблемы является выбор границы воронки выброса как линии тока, на которой функция тока принимает определённое <<критическое>> значение, зависящее от параметров среды.

Метод решения поставленной задачи основан на методе, успешно применённом в работе Л. М. Котляра \cite{phys:Kotlyar} для незаглублённого заряда.
Отличие от работы \cite{phys:Kotlyar} в заглублении заряда и приданию ему эллиптической формы, т.~е., фактически, в переходе к более обобщённой задаче.
Метод Л. М. Котляра основывается на некоторых модификациях метода Чаплыгина \cite{phys:Gurevich} и использовании тета-функций \cite{matan:Whittaker} для построения искомых функций.

Работа \cite{phys:Ilyinskij}, по-видимому, была последней из опубликованных по теме использования ТЖМ во взрывном деле.
Никаких работ с 1986 года больше не издавалось, поэтому, данная работа приобретает особую актуальность как возобновляющая прерванные по тем или иным причинам исследования.

В настоящее время (начало 2011 года) из общедоступных и относительно известных средств моделирования взрывов являются специализированные программные пакеты для персонального компьютера, такие, как LS-DYNA \cite{diploma:Mujzemnek}. Расчёт в этих программах ведётся при помощи различных сеточных методов, рассчитывающих взрыв как определённую деформацию сплошной среды. Такой подход исключительно ресурсозатратный, особенно при необходимости соблюдать высокую точность расчётов, и расчёты по более простой математической модели, такой как ТЖМ, в некоторых случаях будет эффективнее, чем использование подобных программных пакетов.

\section{Обзор технологии параллельных вычислений и современных техник её применения}
Все современные микропроцессоры имеют два или больше ядер и относительно скоро можно ожидать, что количество ядер вырастет до десятков или сотен. Больше нельзя рассчитывать на то, что производительность каждого отдельного ядра будет расти и дальше. Единственный способ достичь увеличения производительности от каждого следующего поколения чипов --- разделить работу программы на множество обрабатывающих данные ядер.

Разделить приложение на множество обрабатывающих ядер возможно, если каким-либо образом автоматически распараллелить последовательный код. Данный подход является текущей областью исследований в области компьютерных наук. Другой подход заключается в написании полу-явно или явно параллельных программ, которые затем будут распределены на множество ядер операционной системой и это именно тот тот подход, который будет использоваться в данной работе.

Следует разделить понятия <<параллельные>>, <<\textit{parallel}>>, вычисления и <<одновременные>>\footnote{Устоявшегося перевода термина \textit{concurrent} на русский язык нет. Поэтому для ясности, так как разница в терминах \textit{parallel} и \textit{concurrent} крайне значительна, везде далее в тексте будет использовано выражение <<одновременная программа>> как перевод фразы <<concurrent program>>}, <<\textit{concurrent}>> вычисления. Параллельная программа написана с конкретной целью воспользоваться потенциалом истинно параллельного вычислительного ресурса, такого, как многоядерного процессора. От параллельной программы мы ожидаем истинно одновременного выполнения. Одновременность же является техникой структурирования программного обеспечения, которая позволяет смоделировать вычисления в виде гипотетически независимых действий, которые могут синхронизироваться и связываться друг с другом.

Написание одновременных и параллельных программ --- гораздо более сложная задача, чем написание последовательных программ. Однако, существуют серьёзные причины для написания одновременных и параллельных программ:
\begin{enumerate}
\item \textbf{Производительность}. Чтобы получить увеличение производительности с каждым новым поколением многоядерных процессоров, нам следует писать параллельные программы.
\item \textbf{Сокрытие задержек}. Даже на одноядерных процессорах мы можем использовать одновременные программы для того, чтобы \\ скрыть от пользователя ожидание медленных операций ввода/вывода на диски и сетевые устройства.
\item \textbf{Структурирование ПО}. Некоторые виды задач могу быть удобным образом представлены в виде множества связанных друг с другом нитей выполнения, что помогает структурировать код более модульным образом. Например, можно моделировать компоненты пользовательского интерфейса как отдельные нити выполнения.
\item \textbf{Одновременность в реальности}. В распределённых системах и системах реального времени приходится моделировать и реагировать на события в реальном мире, например, обрабатывать многочисленные запросы к серверу, параллельно.
\end{enumerate}

Современные микропроцессоры используют так называемый thread-level parallelism, <<параллелизм на уровне нитей выполнения>> \cite[стр.~195]{comp:CompArch}. Это означает, что участки кода, которые должны выполняться параллельно (если это возможно), указываются явно или полу-явно разработчиком программного обеспечения. Будут ли эти участки \emph{действительно} выполняться параллельно, зависит от компилятора программы и от операционной системы, которая будет её выполнять. В любом случае, для описания параллелизма выполнения программы используют понятие <<нить выполнения>> (<<thread>>). Нить выполнения инкапсулирует вычисления, которые должны выполняться одновременно с другими нитями.

В настоящее время существует несколько высокоуровневых техник построения параллельных программ, например, MapReduce \cite{diploma:MapReduce}, Software Transactional Memory \cite{diploma:STM} или модель акторов \cite{web:Erlang-site}.

В программе, которая будет реализована в рамках данного проекта, будет использована как истинная параллельность чисто математических вычислений, так и техника одновременности операций ввода/вывода. Вычисления и диалог с пользователем будут производиться одновременно, что позволит, например, в перспективе --- запустить параллельно несколько вычислений из одного экземпляра программы. Для увеличения производительности же будет использован параллелизм выполнения некоторых вычислительных операций в программе.

\section{Выбор языка программирования}
Для программирования вычислений, с учётом требований, предъявленных к задаче, был выбран язык Haskell \cite{web:Haskell-site}.

Haskell является чисто функциональным строго типизированным языком программирования с <<ленивой>> моделью вычислений. Он одновременно как интерпретируемый, так и компилируемый (доступны как интерпретатор Haskell, так и компилятор). Возможно заниматься отладкой программы в интерпретаторе, с последующей компиляцией исходного кода в нативное приложение, не требующее интерпретатора для выполнения.

Интерпретируемость программ на Haskell облегчает их отладку, написание и переносимость. Функциональная парадигма программирования, лежащая в основе этого языка, облегчает переформулирование математических выкладок, которые будут являться решением поставленной задачи, в программный код.

Более того, синтаксис и выразительность Haskell позволяют в некоторых случаях переписывать математические выражения в программный код <<один-к-одному>>, без издержек на переформулирование в другие абстракции, что является обязательным при использовании императивных языков, таких, как C \cite{prog:K&R}.

Интерпретатор и компилятор Haskell не поддерживают кросс-ком\-пи\-ляцию, но сами скомпилированы для многих платформ, и являются приложениями с открытым исходным кодом, что позволяет переносить программы, написанные на Haskell, относительно простыми методами.

Для Haskell имеется обширная библиотека пакетов, включающая в себя пакет для черчения произвольных графиков функций \\ Graphics.Rendering.Chart \cite{web:Haskell:Chart-wiki}, а также пакет для поддержки истинно параллельных вычислений Control.Parallel \cite{web:Haskell:Parallel-hackage} и пакет для поддержки одновременности выполнения Control.Concurrent \cite{web:Haskell:Concurrent-hackage}.
Следует заметить, что зависимости, наличествующие для пакета Graphics.Rendering.Chart, значительно усложнят сборку приложения для ОС Windows, так как в этой операционной системе отсутствует стандартный удобный для использования из командной строки компилятор языка C.

Чистый параллелизм в Haskell сохраняет детерминизм операций, поэтому его включение в программный код не меняет результата.

С 2004 года традиционный компилятор Haskell, <<GHC>> поддерживает компиляцию программ, способных выполняться параллельно на многоядерных машинах. Для этого требуется компилировать с флагом \\ \verb!-threaded!, и запускать приложение с аргументами командной строки \verb!+RTS -Nn!, где \verb!n! --- это количество ядер, на которые можно рассчитывать в текущей среде выполнения. Запущенное в таком режиме приложение будет пытаться распараллеливать выполнение участков кода, явно помеченных разработчиком как должные выполняться одновременно.

Также можно добиться повышения производительности приложения на языке Haskell, скомпилированного в параллельном режиме, явно указав размер кучи и стека, доступных для приложения. Увеличение кучи ведёт к уменьшению количества запусков сборщика мусора в случае требовательных к ресурсам вычислений, а каждый запуск сборщика мусора уменьшает производительность приложения.

Размер кучи указывается аргументом командной строки для приложения, например \verb!-K100M! указывает использовать 100 MB для стека, а \verb!-H800MB! указывает использовать 800 MB для кучи.




